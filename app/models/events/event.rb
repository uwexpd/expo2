# An Event is anything that could be attended by another object in EXPO, such as a workshop, a meeting, or a conference. Each Event can have multiple EventTimes, allowing you to break down an event into different sections or different options. For example, let's say you offer abstract writing workshops to students. You want to setup 10 different workshop dates, all of which are essentially the same event. You create an Event called "Abstract Writing Workshop," and then for each of the ten dates, you create separate EventTimes. This also allows you to restrict attendees to only attend one of the workshop times by setting the +allow_multiple_times_per_attendee+ to +false+.
class Event < ActiveRecord::Base
  stampable
  has_many :times, :class_name => "EventTime", :conditions => { :type => nil }, :dependent => :destroy do 
    def future; find(:all, :conditions => "start_time > NOW()"); end
  end
  has_many :invitees, :class_name => "EventInvitee", :through => :times
  has_many :attendees, :class_name => "EventInvitee", :through => :times, :conditions => { :attending => true } do
    def tomorrow_reminder
        find(:all, :conditions => "TO_DAYS(start_time) = TO_DAYS(adddate(curdate(),1))")
    end
  end  
  has_many :attended, :class_name => "EventInvitee", :through => :times, :conditions => "checkin_time IS NOT NULL"
  has_many :staff_positions, :class_name => "EventStaffPosition", :dependent => :destroy
  has_many :staff_position_shifts, :class_name => "EventStaffPositionShift", :through => :staff_positions, :source => :shifts
  
  belongs_to :offering
  belongs_to :confirmation_email_template, :class_name => "EmailTemplate", :foreign_key => "confirmation_email_template_id"
  belongs_to :staff_signup_email_template, :class_name => "EmailTemplate", :foreign_key => "staff_signup_email_template_id"
  belongs_to :reminder_email_template,     :class_name => "EmailTemplate", :foreign_key => "reminder_email_template_id"
  belongs_to :unit
  belongs_to :event_type, :class_name => "EventType", :foreign_key => "event_type_id"
  
  validates_presence_of :title, :unit_id

  PLACEHOLDER_CODES = %w( title description )
  PLACEHOLDER_ASSOCIATIONS = %w( offering unit )
  
  named_scope :public, :conditions => { :public => true }
  named_scope :send_reminders, :conditions => "reminder_email_template_id is not null"
  
  def <=>(o)
    title <=> o.title rescue 0
  end

  # Returns true if the object already has an EventInvitee object in the list of invitees and +attending+ is +true+.
  def attending?(obj)
    return false if obj.nil?
    find_attendee(obj).nil? ? false : true
  end

  # Finds an EventInvitee object for this obj, if it exists, or nil.
  def find_attendee(obj)
    return nil if obj.nil?
    klass = obj.class.respond_to?(:parent_class) ? obj.class.parent_class.to_s : obj.class.to_s
    attendees.find_by_invitable_type_and_invitable_id(klass, obj.id)
  end

  # Parses the +extra_fields_to_display+ field into a hash of column titles and code snippets.
  def extra_fields
    return {} if extra_fields_to_display.blank?
    fields = {}
    for field in extra_fields_to_display.split(/$/)
      f = field.strip.split("|")
      fields[f[0]] = f[1]
    end
    fields
  end

  # Parses the +other_nametags+ field into an array of arrays with one item per "line" of the nametag.
  def other_nametags
    raw = read_attribute(:other_nametags)
    raw.split(/$/).collect{|r| r.strip.split("|")}
  end
  
  # Returns a new or existing Population with the requested starting set. The starting set can be any valid association
  # or method of this Offering that returns an array of objects. If the population doesn't exist, it is created and the
  # +system+ boolean flag is set.
  # 
  # Since Populations must have a unique title, this method will automatically increment the title for a newly-created
  # Population if needed. So if a population with the name already exists, this method will create a population with a
  # "2" at the end of the title. If something with a "2" already exists, the new title will have a "3", and so on, until
  # a valid title is found.
  def population(starting_set)
    starting_set = starting_set.to_s if starting_set.is_a?(Symbol)
    p = Population.find_or_initialize_by_populatable_type_and_populatable_id_and_starting_set_and_conditions_counter(
          "Event", self.id, starting_set, 0)
    if p.new_record?
      p.title = "#{self.title}: #{starting_set.titleize}"
      until p.valid? && !p.errors.on(:title)
        if p.title[/\d+$/].nil?
          p.title += " 2"
        else
          new_num = p.title[/\d+$/].to_i + 1
          p.title.gsub!(/\d+$/, new_num.to_s)
        end
      end 
      p.system = true
      p.description = "Automatically generated by Event ##{self.id} from starting set '#{starting_set}'"
      p.access_level = "unit"
      p.save
    end
    p
  end
  
  # Create a copy event including times, staff_positions, staff_positions_shifts
  def deep_clone!
    opts = {}
    opts[:except] = [            
        :other_nametags,
        :updated_at
      ]
    opts[:include] = [
      :times,
      {:staff_positions => :shifts }
      ]
    copy = self.clone(opts) 
    copy.update_attribute(:title, copy.title.to_s + " Copy")
    copy
  end
  
  # Send a reminder to user, a day before event time
  def send_attendee_reminder!
    template = EmailTemplate.find(reminder_email_template_id)
    return false if template.nil?
    attendees.tomorrow_reminder.each do |attendee|
        EmailContact.log(
          attendee.invitable_id, 
          TemplateMailer.deliver(template.create_email_to(attendee)),
          nil, nil,
          attendee
        )
    end
  end
  
end
